import java.util.concurrent.Callable
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.concurrent.Future

sourceCompatibility = JavaVersion.VERSION_11
targetCompatibility = JavaVersion.VERSION_16
tasks.withType(JavaCompile) {
    options.compilerArgs.addAll(['--release', '11'])//android 4.4 like java 8
}

static String getHttp(String jarUrl, ModuleVersionIdentifier dependency) {
    try {
        URL jarfile = new URL(jarUrl)
        InputStream inStream = jarfile.openStream()
        if (inStream != null) {
            String qualified = String.format("%s:%s:%s", dependency.group, dependency.name, dependency.version)

            return qualified + " " + jarUrl
        }
    } catch (FileNotFoundException e) {
        //System.err.println(e.toString());
        //System.err.println(jarUrl);
    } catch (Exception e) {
        System.err.println(e.toString())
        System.err.println(jarUrl)
    }
    return null
}



dependencies {
    compileOnly(atomModule(":Atomic")) {
        because("runtime")
    }
    compileOnly(atomModule(":Desktop")) {
        because("runtime")
    }
    compileOnly (group: 'com.aparapi', name: 'aparapi', version: '2.0.0') {because("runtime")}

    //compileOnly (group: 'org.jblas', name: 'jblas', version: '1.2.5') {because("runtime")}
    compileOnly (group: 'io.jenetics', name: 'jenetics', version: '6.2.0') {
        because("runtime")
    }
    compileOnly (group: 'org.deeplearning4j', name: 'deeplearning4j-nn', version: '1.0.0-M1') {
        because("runtime")
    }
    compileOnly (group: 'org.jfree', name: 'jfreechart', version: '1.5.3') {
        because("runtime")
    }
    testImplementation group: 'org.jfree', name: 'jfreechart', version: '1.5.3'
    testImplementation group: 'org.deeplearning4j', name: 'deeplearning4j-nn', version: '1.0.0-M1'
    testImplementation group: 'com.aparapi', name: 'aparapi', version: '2.0.0'
    testImplementation group: 'io.jenetics', name: 'jenetics', version: '6.2.0'
    testImplementation group: 'org.jblas', name: 'jblas', version: '1.2.5'
    testImplementation(atomModule(":Atomic"))
    testImplementation(atomModule(":Desktop"))
    testImplementation(aproj(":core"))
    implementation(aproj(":core")) {
        exclude group: "com.github.o7-Fire.Atomic-Library", module: "Atomic"
    }

}


task collectAllDeps {
    doLast {



    }
}
task writeDependency() {
    File txt = new File(projectDir, "src/main/resources/dependencies")
    txt.parentFile.mkdirs()
    txt = txt.getAbsoluteFile()
    txt.createNewFile()
    doLast {
        println txt
        txt.delete()
        Properties depends = new Properties()
        ArrayList<Future<String>> task = new ArrayList<>()
        ExecutorService service = Executors.newCachedThreadPool()
        HashSet<String> exist = new HashSet<>()
        configurations.runtimeClasspath.getResolvedConfiguration().getResolvedArtifacts().each{
            ModuleVersionIdentifier dep = it.getModuleVersion().getId()
            exist.add("$dep.group:$dep.name")
        }
        def conf = configurations.compileClasspath

            println conf.name
            conf.getResolvedConfiguration().getResolvedArtifacts().each {
                ModuleVersionIdentifier dep = it.getModuleVersion().getId()
                if(exist.contains("$dep.group:$dep.name"))return;
                println "$dep.group:$dep.name:$dep.version"

                for (ArtifactRepository repository : project.repositories.asList()) {
                    try {
                        String url = repository.properties.get('url')
                        if (!url.startsWith("http"))continue;
                        if (!url.endsWith("/"))
                            url = url + "/"
                        String jarUrl = String.format("%s%s/%s/%s/%s-%s.jar", url.toString(),
                                dep.group.replace('.', '/'), dep.name, dep.version,
                                dep.name, dep.version)
                        Future<String> f = service.submit(new Callable<String>() {//so you can't use lambda, day ruined
                            @Override
                            String call() throws Exception {
                                return getHttp(jarUrl, dep)
                            }
                        })
                        task.add(f)
                    } catch (Exception e) {
                    }
                }
            }


        println task.size() + " searching"
        for (Future<String> f : task) {
            //println f.get()
            String kyys = f.get()
            if (kyys == null) continue

            String[] kyss = kyys.split(" ")
            String qualified = kyss[0], jarUrl = kyss[1]

            println(qualified + " -> " + jarUrl)
            if (depends.getProperty(qualified))
                jarUrl = depends.getProperty(qualified) + " " + jarUrl
            depends.setProperty(qualified, jarUrl)
        }
        Calendar c = Calendar.getInstance()
        String date = String.format(Locale.UK, "%tl:%tM:%tS %tp %tB %te, %tY", c, c, c, c, c, c, c)
        depends.store(new FileWriter(txt), "this tbh \n" + date)


    }
}
task base(type: Jar, dependsOn: ":core:compileJava") {
    archiveFileName = "desktop.jar"
    duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
    manifest.attributes('Main-Class': modsNJavaMain)//what
    with jar
    from {
        configurations.runtimeClasspath.filter { it.exists() }.collect { it.isDirectory() ? it : zipTree(it) }
    }

    from files(aproj(":core").sourceSets.main.output)//Include core project class, gradle is shit

}
task unVersion(type: JavaExec) {
    classpath = sourceSets.main.runtimeClasspath + sourceSets.main.compileClasspath
    main = "org.o7.Fire.Glopion.Version"
    setWorkingDir(rootDir)
}
task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'//deprecated
    from sourceSets.main.allSource
}
artifacts {
    archives sourcesJar
    archives base
}
