import arc.util.OS

import java.nio.file.Files
import java.nio.file.StandardCopyOption
import java.nio.file.StandardOpenOption
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

buildscript {
    repositories {//more than you need
        mavenLocal()
        mavenCentral()
        maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
        maven { url "https://oss.sonatype.org/content/repositories/releases/" }
        maven { url 'https://jitpack.io' }
        google()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }

    dependencies {
        classpath("com.github.Anuken.Arc:arc-core:$arcHash")//why not
        classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:3.3"
    }

}

apply plugin: 'java'
apply plugin: 'java-library'


sourceCompatibility = JavaVersion.VERSION_16
targetCompatibility = JavaVersion.VERSION_1_8


//github CI don't sort folder by default
static File getLatestFolder(File fe) {
    ArrayList<File> f = new ArrayList<>();
    if (!fe.exists()) throw new FileNotFoundException(fe.getAbsolutePath());
    File[] files = fe.listFiles();
    f.addAll(Arrays.asList(files));
    f.sort(new Comparator<File>() {
        @Override
        public int compare(File o1, File o2) {
            return o1.getAbsolutePath() <=> o2.getAbsolutePath();
        }
    });
    return f.get(f.size() - 1);
}

allprojects {

    apply plugin: 'java'
    apply plugin: 'java-library'
    apply plugin: "org.sonarqube"
    apply plugin: 'jacoco'
    sonarqube {
        properties {
            property "sonar.projectKey", "o7-Fire_Mindustry-Glopion"
            property "sonar.organization", "o7-ire"
        }
    }
    jacocoTestReport {
        reports {
            xml.enabled true
        }
    }
    try {
        buildScan {
            termsOfServiceUrl = 'https://gradle.com/terms-of-service'
            termsOfServiceAgree = 'yes'
        }
    } catch (e){

    }
    tasks.withType(Test) {
        useJUnitPlatform()
        finalizedBy(jacocoTestReport)
        testLogging {
            // set options for log level LIFECYCLE
            events TestLogEvent.FAILED,
                    TestLogEvent.PASSED,
                    TestLogEvent.SKIPPED,
                    TestLogEvent.STANDARD_OUT
            exceptionFormat TestExceptionFormat.FULL
            showExceptions true
            showCauses true
            showStackTraces true
            ignoreFailures true
            failFast true
            setWorkingDir(rootProject.projectDir)
            // set options for log level DEBUG and INFO
            debug {
                events TestLogEvent.STARTED,
                        TestLogEvent.FAILED,
                        TestLogEvent.PASSED,
                        TestLogEvent.SKIPPED,
                        TestLogEvent.STANDARD_ERROR,
                        TestLogEvent.STANDARD_OUT
                exceptionFormat TestExceptionFormat.FULL
            }
            info.events = debug.events
            info.exceptionFormat = debug.exceptionFormat
            maxParallelForks = 1
            forkEvery = 1
            beforeTest { descriptor ->
                logger.lifecycle("Running test: " + descriptor)
            }
            afterSuite { desc, result ->
                if (!desc.parent) { // will match the outermost suite
                    def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} passed, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
                    def startItem = '|  ', endItem = '  |'
                    def repeatLength = startItem.length() + output.length() + endItem.length()
                    println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
                    if(result.failedTestCount > 0)throw new Exception("Fail")
                }
            }
        }
    }

    repositories {
        mavenLocal()
        mavenCentral()
        maven { url "https://oss.sonatype.org/content/repositories/snapshots/" }
        maven { url "https://oss.sonatype.org/content/repositories/releases/" }
        maven { url 'https://jitpack.io' }
    }
    group = 'com.o7.Fire.Glopion'
    version = modsNversion
    ext.atomModule = { String module ->
        boolean b = new File(rootDir, '../Atom').exists()
        b = false
        if (b) {
            return project(":Atom" + module)
        } else {
            return "com.github.o7-Fire.Atomic-Library$module:$atomHash"
        }
    }
    ext.aproj = { String module ->
        if (findProject(module) != null) {
            return project(module)
        } else {
            return project(":" + modsNname + module)
        }
    }
    ext {
        try {
            System.properties.load(new FileReader("gradle.properties"))
            System.properties.load(new FileReader("local.properties"))
        } catch (ignored) {
        }
        //System.out.println(System.getProperty("modsNBE"))
        //automatically detect latest shit and skipping it if doesn't exists
        //export ANDROID_HOME=~/android-sdk
        isRunner = System.getProperty("user.name").equals("runner")
        sdkRoot = System.getenv("ANDROID_HOME")//or just replace it by direct path if you don't need github
        if (sdkRoot == null)
            sdkRoot = new File("SDK").getAbsolutePath()
        sdkD8 = sdkRoot + "nope"
        sdkJar = sdkRoot + "nope"//nopped in case folder didn't exist
        sdkRootf = new File(sdkRoot)
        if (sdkRootf.exists()) {
            try {
                sdkD8 = new File(getLatestFolder(new File(sdkRootf, 'build-tools/')), "d8").getAbsolutePath()
                sdkJar = new File(getLatestFolder(new File(sdkRootf, "platforms/")), "android.jar").getAbsolutePath()
            } catch (ignored) {
                //FileNotFoundException
            }
        }
        if (!new File(sdkJar).exists())//redundant ?
            sdkJar = new File(sdkRoot, "nope").getAbsolutePath()
        if (!new File(sdkD8).exists())
            sdkD8 = new File(sdkRoot, "nope").getAbsolutePath()
        androidJarFile = new File(sdkJar)
        mindustryExecutable = getMindustryFile()
        mindustryServerExecutable = getMindustryServerFile()
        //imagine writing json
        modhjson = ""
        modhjson += 'name: "' + modsNname + '"\n'
        modhjson += 'displayName: "' + modsNdisplayName + '"\n'
        modhjson += 'description: "' + modsNdescription + '"\n'
        modhjson += 'author: "' + modsNauthor + '"\n'
        modhjson += 'main: "' + modsNmain + '"\n'
        modhjson += 'minGameVersion: ' + modsNminMindustryVersion + '\n'
        modhjson += "version: " + modsNversion + "\n"
        modhjson += 'hidden: ' + modsNsupportVanillaServer + '\n'
        githubRepoExist = false
        if (project.hasProperty("githubRepo"))//supplied by workflow runner (gradle.yml)  -PgithubRepo="$GITHUB_REPOSITORY"
        {
            githubRepoExist = true
            modhjson += 'repo: \"' + githubRepo + '\" \n'
        } else
            modhjson += 'repo: "' + modsNrepo + '"\n'


        //From Root to every project
        dependencies {
            //
            def be = System.getProperty("modsNBE") != null && !System.getProperty("modsNBE").isEmpty()
            if (be) {
                downloadMindustry(getMindustryURL(), getMindustryFile());
            }
            File mindustry = file(mindustryExecutable)
            if (be && mindustry.exists()) {
                compileOnly(files(mindustry))
                //testCompileOnly(files(mindustry))
                testImplementation(files(mindustry))
            } else {//if you feel fancy remove this else
                compileOnly("com.github.Anuken.Mindustry:desktop:$mindustryHash")
                compileOnly("com.github.Anuken.Arc:arc-core:$arcHash")
                compileOnly("com.github.Anuken.Arc:backend-sdl:$arcHash")
                compileOnly("com.github.Anuken.Mindustry:core:$mindustryHash")
            }
            testImplementation 'org.junit.jupiter:junit-jupiter:5.7.0'
            testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.3.1'
            testRuntimeOnly(files(mindustryExecutable))
            testRuntimeOnly(files(mindustryServerExecutable))

            compileOnly group: 'org.jetbrains', name: 'annotations', version: '21.0.1'

        }
        tasks.withType(JavaCompile) {
            options.encoding = "UTF-8"
            options.compilerArgs += ["-Xlint:deprecation", "-g"]

            options.forkOptions.jvmArgs.addAll([
                    '--add-opens=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED',
                    '--add-opens=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED'
            ])
        }
        tasks.withType(Javadoc) {
            options {
                addStringOption('Xdoclint:none', '-quiet')
                addStringOption('-release', '16')
            }
        }
    }
}
subprojects {

    dependencies {

        testImplementation(files(mindustryExecutable))
        testImplementation(files(mindustryServerExecutable))
        testImplementation(rootProject)
        //compileOnly(files(mindustryExecutable))
        compileOnly(rootProject)
    }

}
ext {
    println System.getenv("ANDROID_HOME") == null ? "Android SDK doesn't exist" : "Android SDK exist"
    //rewrite mod.hjson everytime gradle rollin
    //println System.getenv("ANDROID_HOME")
    try {
        File f = new File(projectDir, "mod.hjson")
        f.delete()
        Files.write(f.toPath(), modhjson.toString().getBytes(), StandardOpenOption.WRITE, StandardOpenOption.CREATE);
    } catch (ignored) {
    }
    File props = new File(projectDir, 'gradle.properties')
    File atom = new File(projectDir, '../Atom')
    if (atom.exists() && props.exists()) {
        String s = new String(Runtime.getRuntime().exec("git rev-parse HEAD", new String[0], atom).getInputStream().readAllBytes()).trim();
        if (s != atomHash) {
            Properties properties = new Properties()
            StringWriter writer = new StringWriter();
            properties.load(props.toURI().toURL().openStream());
            properties.put("atomHash", s);
            properties.store(writer, "Touch")
            Files.writeString(props.toPath(), writer.getBuffer().toString(), StandardOpenOption.WRITE);
            atomHash = s;
        }
    }
}


//Root Module only
dependencies {

    annotationProcessor "com.github.Anuken:jabel:$jabelVersion"
    testAnnotationProcessor "com.github.Anuken:jabel:$jabelVersion"
    if(androidJarFile.exists())
        compileOnly(files(androidJarFile))
}

//make .class jar with executable main and MANIFEST.MF
//your typical jar
task base(type: Jar) {
    archiveFileName = modsNname + ".jar"//Mindustry-Glopion,jar
    duplicatesStrategy(DuplicatesStrategy.EXCLUDE)//stop including duplicated copy of library, D8 really mad
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
//Runtime library only, compile library like arc won't get included
    }
    with jar//what is this
    manifest {
        attributes(
                'Main-Class': modsNJavaMain
        )
    }


    from(rootDir) {
        include "mod.hjson"//assuming the rootdir is actually current folder
        include "icon.png"
    }
}
//source code documentation instead of decompiled .class, if you use jitpack that is
task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'//deprecated
    from sourceSets.main.allSource
}
//not jar task
//just handle making dexed jar after making typical jar
task baseJar(type: Jar) {
    dependsOn base//typical jar

    //collect dependencies needed for desugaring
    if (new File(sdkD8).exists()) {
        def files = (configurations.compileClasspath.asList() + configurations.runtimeClasspath.asList() + [new File(sdkJar)])
//all dependency go
        def dependencies = files.collect { "--classpath $it.path" }.join(" ")//argument builder
        def cmd = "${sdkD8} $dependencies --min-api ${minAndroidApi} --output Dex.jar ${modsNname}.jar"
//should output Dex.jar from Mindustry-Glopion.jar
        def dir = new File(projectDir, "build/libs/");
        dir.mkdirs()//cuz sike, file not found exception
        doLast {
            if (new File(sdkD8).exists() && new File(sdkJar).exists()) {
                println(cmd)//comment this to disable spam
                Runtime.getRuntime().exec(cmd, new String[0], dir).waitForProcessOutput(System.out, System.err)
            }
        }
    } else {
        println "No sdkD8 detected on ANDROID_HOME, skipping desugaring"//y not
    }
}

tasks.withType(JavaCompile) {
    options.compilerArgs.addAll(['--release', '8'])//android 4.4 like java 8
}
//here we combine typical jar and dex jar to make
//typical-dex.jar
//if android sdk exist
task makeJar(type: Jar) {
    dependsOn baseJar//dex jar
    manifest {
        attributes(
                'Main-Class': modsNJavaMain
        )
    }
    if (new File(sdkD8).exists()) {//some people don't have android SDK
        archiveFileName = modsNname + "-Dexed.jar"

        duplicatesStrategy(DuplicatesStrategy.EXCLUDE)
        if (new File(sdkD8).exists()) {
            from() {
                zipTree(new File(projectDir, "build/libs/Dex.jar"))//include Dex.jar
            }
        }
    } else {
        println "No sdkD8 detected on ANDROID_HOME, skipping making Combined Dex-Class Jar"
    }
    from() {
        zipTree(new File(projectDir, "build/libs/${modsNname}.jar"))//include YourModsName.jar or typical.jar
    }
}




//need this for jitpack, so i can read mods source code without using browser
artifacts {
    archives sourcesJar
    archives base
}

//h
//add progress bar
static void downloadMindustry(URL url, File download) {
    download.getParentFile().mkdirs();
    if (download.exists()) return;
    System.out.println("Downloading: " + url.toString());

    HttpURLConnection con = (HttpURLConnection) url.openConnection();
    BufferedInputStream input = new BufferedInputStream(con.getInputStream());
    download.getAbsoluteFile().getParentFile().mkdirs();
    RandomAccessFile output = new RandomAccessFile(download, "rw");

    int bytesRead;
    byte[] buffer = new byte[4096];
    long nextLog = System.currentTimeMillis() + 4000
    long readed = 0;
    while ((bytesRead = input.read(buffer)) != -1) {
        readed += bytesRead;
        output.write(buffer, 0, bytesRead);
        if (System.currentTimeMillis() > nextLog) {
            System.out.println(readed / 1_000_000)
            nextLog = System.currentTimeMillis() + 4000
        }
    }
    output.close()

}
//don't crash
static void copyToMindustry(File f) {
    File target = new File(OS.getAppDataDirectoryString("Mindustry"))
    target = new File(target, "mods")
    target = new File(target, f.getName())
    target.getParentFile().mkdirs()
    System.out.println("Copying: " + f.getAbsolutePath() + " to " + target.getAbsolutePath());
    Files.copy(f.toPath(), target.toPath(), StandardCopyOption.REPLACE_EXISTING);
}

static URL getMindustryServerURL() {
    if (System.getProperty("modsNBE", null) != null) {
        String h = System.getProperty("modsNBE");
        return new URL("https://github.com/Anuken/MindustryBuilds/releases/download/" + h + "/Mindustry-BE-Server-" + h + ".jar")
    }
    return new URL("https://github.com/Anuken/Mindustry/releases/download/" + System.getProperty("mindustryHash") + "/server-release.jar");
}

static File getMindustryServerFile() {
    URL u = getMindustryServerURL()
    File mindustry = new File(new File(new File(OS.getAppDataDirectoryString("Mindustry")), "build/cache/"), u.getFile());
    return mindustry.getAbsoluteFile();
}

static URL getMindustryURL() {
    if (System.getProperty("modsNBE", null) != null) {
        String h = System.getProperty("modsNBE");
        return new URL("https://github.com/Anuken/MindustryBuilds/releases/download/" + h + "/Mindustry-BE-Desktop-" + h + ".jar")
    }
    return new URL("https://github.com/Anuken/Mindustry/releases/download/" + System.getProperty("mindustryHash") + "/Mindustry.jar");
}

static File getMindustryFile() {
    URL u = getMindustryURL()
    File mindustry = new File(new File(new File(OS.getAppDataDirectoryString("Mindustry")), "build/cache/"), u.getFile());
    return mindustry.getAbsoluteFile();
}

//how lazy to download this
task download() {
    doLast {
        downloadMindustry(getMindustryServerURL(), getMindustryServerFile());
        downloadMindustry(getMindustryURL(), getMindustryFile());
    }
}
//don't want open file manager
task copyMods() {
    dependsOn base//you don't need dex jar for pc
    doLast {
        File srcJar = new File(new File(projectDir.toString()), "build/libs/" + modsNname + ".jar")
        copyToMindustry(srcJar)
        File target = new File(projectDir.toString(), "config/mods/" + modsNname + ".jar")
        target.getParentFile().mkdirs()
        System.out.println("Copying: " + srcJar.getAbsolutePath() + " to " + target.getAbsolutePath());
        Files.copy(srcJar.toPath(), target.toPath(), StandardCopyOption.REPLACE_EXISTING);
    }
}
//java -jar Mindustry.jar
//cooler java -jar Mindustry.jar
task run(type: JavaExec) {
    dependsOn download
    dependsOn copyMods//make class jar then copy it, why the hell you need to dex it
    File mindustry = getMindustryFile()
    println(mindustry.getAbsolutePath())
    classpath = files(mindustry.getAbsolutePath())
    //classpath += sourceSets.main.runtimeClasspath//will append classpath to java
    main = "mindustry.desktop.DesktopLauncher"
}
task resolveDependencies {
    doLast {
        rootProject.allprojects { project ->
            Set<Configuration> configurations = project.buildscript.configurations + project.configurations
            configurations.findAll { c -> c.canBeResolved }.forEach { c -> c.resolve() }
        }
    }
}
task deploy {
    dependsOn makeJar
    dependsOn ":core:makeJar"
    dependsOn ":desktop:base"
    dependsOn ":desktop:unVersion"
}
test.dependsOn(download)
test.dependsOn(copyMods)
